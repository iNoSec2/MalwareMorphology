# Lab 5 - Identifying Necessity and Sufficiency

## Lab Objectives
* Learn how to identify what operations have to be performed in order for the desired action to take place
* Better understand what makes an operation necessity and/or sufficiency

## Source Code: 
[SetThreadToken](https://github.com/jaredcatkinson/MalwareMorphology/tree/main/SetThreadToken)

## Part 1: Background
For the technique [T1134.001 - Access Token Manipulation: Token Impersonation/Theft](https://attack.mitre.org/techniques/T1134/001/) it mentions that there are 2 functions that can be used to impersonate a token and set that token to a given thread. One being SetThreadToken and the other being ImpersonateLoggedOnUser. We have looked at both of these functions before, but moving forward we will look at SetThreadToken. 

We have seen the code for the SetThreadToken proof-of-concept (linked above) before. We also have seen and talked about the function calls that are executed before SetThreadToken, but we haven't talked about why. Within each technique there are a set of operations that are performed in order for the technique to be successful. Some of those functions only exist because they will output a pointer to some object, place in memory, or attribute that another function needs to execute properly. These functions are called necessary functions. The output they provide is what allows for the ending function to be successful. The ending function of a technique is called a sufficient function. Sufficiency occurs when a function is executed an the operation and doesn't pass on an output that is needed for something else. There may be post-sufficent actions that occur that take the sufficient function as an input, but the desired outcome was achieved for that behavior already. SetThreadToken is an example of this because it sets a token to a thread. Once that token is set and adversary can perform different actions with that thread but it isn't inputted into anything else. 

## Part 2: Identify the Necessary Function for SetThreadToken

Looking at the parameters for SetThreadToken:
SetThreadToken parameters:
```
BOOL SetThreadToken(
  [in, optional] PHANDLE Thread,
  [in, optional] HANDLE  Token
);
```
We can see that it takes in 2 parameters: 
1. A handle to a thread
2. A handle to a token

Let's look at the handle for the token aspect. How does SetThreadToken obtain this token to set? One way is through a Win32 API called [OpenProcessToken](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken). Without this token, SetThreadToken can't execute. Due to this, OpenProcessToken is considered a necessary function for SetThreadToken. We aren't done yet. 

#### Step 1: Identify the Necessary Function for OpenProcessToken

It isn't uncommon for a function to need some input parameters and OpenProcessToken is no different. Because a token lives within a process or for impersonation tokens a thread, access to that object needs to be obtained. This is evident in OpenProcessToken's function defintion: 

```
BOOL OpenProcessToken(
  [in]  HANDLE  ProcessHandle,
  [in]  DWORD   DesiredAccess,
  [out] PHANDLE TokenHandle
);
```

There are 2 input parameters here: 
1. A handle to a process
2. A DWORD that specifies the desired rights the callee wants to the target object. If we look at SetThreadToken the access it needs to set a token to a thread it needs TOKEN_IMPERSONATE access to the target token

After looking at the input parameters, it is clear that OpenProcessToken needs a handle to a process. Specifically with PROCESS_QUERY_LIMITED_INFORMATION process access rights. This can be achieved via the Win32 API - OpenProcess. This makes OpenProcess a necessary function for OpenProcess and in turn in this operation chain - SetThreadToken. 


#### Step 2: Identify the Necessary Function for OpenProcess
OpenProcess is a very common API used in a lot of operational chains. It takes in 3 input parameters: 
```
HANDLE OpenProcess(
  [in] DWORD dwDesiredAccess,
  [in] BOOL  bInheritHandle,
  [in] DWORD dwProcessId
);
```

The only input parameter that can come from another function is the ProcessId parameter. This can be grabbed a number of different ways, so we will stop there. However; we can identify that a Process Enumeration operation is a necessary operation for OpenProcess. 

## Conclusion

Through this lab we have identified that in order for SetThreadToken to be successful the following has to be executed: 
1. Process enumeration and a target process picked 
2. OpenProcess (or any other lower level function in the OpenProcess callstack)
3. OpenProcessToken (or any other lower level function in the OpenProcessToken callstack)


This makes all of these functions and operations necessary for SetThreadToken. However; if an alert for SetThreadToken fires then we can assume that because SetThreadToken is called then the necessary functions that were also executed. However; if a call to OpenProcess is called we can not say that SetThreadToken was called and/or will be called because OpenProcess provides an output that could go a large variety of functions. 
